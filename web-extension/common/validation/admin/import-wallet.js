/// Autogenerated by `make` target `schemas`
'use strict'; export const validate = validate14; export default validate14; const schema16 = { type: 'object', additionalProperties: false, required: ['wallet', 'passphrase', 'recoveryPhrase', 'keyDerivationVersion'], properties: { wallet: { type: 'string' }, passphrase: { type: 'string' }, recoveryPhrase: { type: 'string' }, keyDerivationVersion: { enum: [2] } } }; function validate14 (data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) { let vErrors = null; let errors = 0; if (data && typeof data === 'object' && !Array.isArray(data)) { if (data.wallet === undefined) { const err0 = { instancePath, schemaPath: '#/required', keyword: 'required', params: { missingProperty: 'wallet' }, message: "must have required property '" + 'wallet' + "'" }; if (vErrors === null) { vErrors = [err0] } else { vErrors.push(err0) }errors++ } if (data.passphrase === undefined) { const err1 = { instancePath, schemaPath: '#/required', keyword: 'required', params: { missingProperty: 'passphrase' }, message: "must have required property '" + 'passphrase' + "'" }; if (vErrors === null) { vErrors = [err1] } else { vErrors.push(err1) }errors++ } if (data.recoveryPhrase === undefined) { const err2 = { instancePath, schemaPath: '#/required', keyword: 'required', params: { missingProperty: 'recoveryPhrase' }, message: "must have required property '" + 'recoveryPhrase' + "'" }; if (vErrors === null) { vErrors = [err2] } else { vErrors.push(err2) }errors++ } if (data.keyDerivationVersion === undefined) { const err3 = { instancePath, schemaPath: '#/required', keyword: 'required', params: { missingProperty: 'keyDerivationVersion' }, message: "must have required property '" + 'keyDerivationVersion' + "'" }; if (vErrors === null) { vErrors = [err3] } else { vErrors.push(err3) }errors++ } for (const key0 in data) { if (!((((key0 === 'wallet') || (key0 === 'passphrase')) || (key0 === 'recoveryPhrase')) || (key0 === 'keyDerivationVersion'))) { const err4 = { instancePath, schemaPath: '#/additionalProperties', keyword: 'additionalProperties', params: { additionalProperty: key0 }, message: 'must NOT have additional properties' }; if (vErrors === null) { vErrors = [err4] } else { vErrors.push(err4) }errors++ } } if (data.wallet !== undefined) { if (typeof data.wallet !== 'string') { const err5 = { instancePath: instancePath + '/wallet', schemaPath: '#/properties/wallet/type', keyword: 'type', params: { type: 'string' }, message: 'must be string' }; if (vErrors === null) { vErrors = [err5] } else { vErrors.push(err5) }errors++ } } if (data.passphrase !== undefined) { if (typeof data.passphrase !== 'string') { const err6 = { instancePath: instancePath + '/passphrase', schemaPath: '#/properties/passphrase/type', keyword: 'type', params: { type: 'string' }, message: 'must be string' }; if (vErrors === null) { vErrors = [err6] } else { vErrors.push(err6) }errors++ } } if (data.recoveryPhrase !== undefined) { if (typeof data.recoveryPhrase !== 'string') { const err7 = { instancePath: instancePath + '/recoveryPhrase', schemaPath: '#/properties/recoveryPhrase/type', keyword: 'type', params: { type: 'string' }, message: 'must be string' }; if (vErrors === null) { vErrors = [err7] } else { vErrors.push(err7) }errors++ } } if (data.keyDerivationVersion !== undefined) { if (!(data.keyDerivationVersion === 2)) { const err8 = { instancePath: instancePath + '/keyDerivationVersion', schemaPath: '#/properties/keyDerivationVersion/enum', keyword: 'enum', params: { allowedValues: schema16.properties.keyDerivationVersion.enum }, message: 'must be equal to one of the allowed values' }; if (vErrors === null) { vErrors = [err8] } else { vErrors.push(err8) }errors++ } } } else { const err9 = { instancePath, schemaPath: '#/type', keyword: 'type', params: { type: 'object' }, message: 'must be object' }; if (vErrors === null) { vErrors = [err9] } else { vErrors.push(err9) }errors++ }validate14.errors = vErrors; return errors === 0 }
