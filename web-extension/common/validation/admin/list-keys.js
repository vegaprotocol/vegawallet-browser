/// Autogenerated by `make` target `schemas`
'use strict'; export const validate = validate14; export default validate14; const schema16 = { type: 'object', required: ['wallet', 'passphrase'], additionalProperties: false, errorMessage: '`admin.list_keys` must only be given `wallet`, `passphrase`', properties: { wallet: { type: 'string' }, passphrase: { type: 'string' } } }; function validate14 (data, { instancePath = '', parentData, parentDataProperty, rootData = data } = {}) { let vErrors = null; let errors = 0; if (data && typeof data === 'object' && !Array.isArray(data)) { if (data.wallet === undefined) { const err0 = { instancePath, schemaPath: '#/required', keyword: 'required', params: { missingProperty: 'wallet' }, message: "must have required property '" + 'wallet' + "'" }; if (vErrors === null) { vErrors = [err0] } else { vErrors.push(err0) }errors++ } if (data.passphrase === undefined) { const err1 = { instancePath, schemaPath: '#/required', keyword: 'required', params: { missingProperty: 'passphrase' }, message: "must have required property '" + 'passphrase' + "'" }; if (vErrors === null) { vErrors = [err1] } else { vErrors.push(err1) }errors++ } for (const key0 in data) { if (!((key0 === 'wallet') || (key0 === 'passphrase'))) { const err2 = { instancePath, schemaPath: '#/additionalProperties', keyword: 'additionalProperties', params: { additionalProperty: key0 }, message: 'must NOT have additional properties' }; if (vErrors === null) { vErrors = [err2] } else { vErrors.push(err2) }errors++ } } if (data.wallet !== undefined) { if (typeof data.wallet !== 'string') { const err3 = { instancePath: instancePath + '/wallet', schemaPath: '#/properties/wallet/type', keyword: 'type', params: { type: 'string' }, message: 'must be string' }; if (vErrors === null) { vErrors = [err3] } else { vErrors.push(err3) }errors++ } } if (data.passphrase !== undefined) { if (typeof data.passphrase !== 'string') { const err4 = { instancePath: instancePath + '/passphrase', schemaPath: '#/properties/passphrase/type', keyword: 'type', params: { type: 'string' }, message: 'must be string' }; if (vErrors === null) { vErrors = [err4] } else { vErrors.push(err4) }errors++ } } } else { const err5 = { instancePath, schemaPath: '#/type', keyword: 'type', params: { type: 'object' }, message: 'must be object' }; if (vErrors === null) { vErrors = [err5] } else { vErrors.push(err5) }errors++ } if (errors > 0) { const emErrs0 = []; for (const err6 of vErrors) { if (((((err6.keyword !== 'errorMessage') && (!err6.emUsed)) && ((err6.instancePath === instancePath) || ((err6.instancePath.indexOf(instancePath) === 0) && (err6.instancePath[instancePath.length] === '/')))) && (err6.schemaPath.indexOf('#') === 0)) && (err6.schemaPath['#'.length] === '/')) { emErrs0.push(err6); err6.emUsed = true } } if (emErrs0.length) { const err7 = { instancePath, schemaPath: '#/errorMessage', keyword: 'errorMessage', params: { errors: emErrs0 }, message: '`admin.list_keys` must only be given `wallet`, `passphrase`' }; if (vErrors === null) { vErrors = [err7] } else { vErrors.push(err7) }errors++ } const emErrs1 = []; for (const err8 of vErrors) { if (!err8.emUsed) { emErrs1.push(err8) } }vErrors = emErrs1; errors = emErrs1.length }validate14.errors = vErrors; return errors === 0 }
