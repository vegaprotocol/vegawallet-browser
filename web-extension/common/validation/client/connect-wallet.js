/// Autogenerated by `make` target `schemas`
"use strict";export const validate = validate14;export default validate14;const schema16 = {"type":"object","required":["hostname"],"additionalProperties":false,"errorMessage":"`client.connect_wallet` must only be given `hostname`","properties":{"hostname":{"type":"string","errorMessage":"`hostname` must be a string"}}};function validate14(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(data && typeof data == "object" && !Array.isArray(data)){if(data.hostname === undefined){const err0 = {instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: "hostname"},message:"must have required property '"+"hostname"+"'"};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}for(const key0 in data){if(!(key0 === "hostname")){const err1 = {instancePath,schemaPath:"#/additionalProperties",keyword:"additionalProperties",params:{additionalProperty: key0},message:"must NOT have additional properties"};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}}if(data.hostname !== undefined){if(typeof data.hostname !== "string"){const err2 = {instancePath:instancePath+"/hostname",schemaPath:"#/properties/hostname/type",keyword:"type",params:{type: "string"},message:"must be string"};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(errors > 0){const emErrs0 = [];for(const err3 of vErrors){if(((((err3.keyword !== "errorMessage") && (!err3.emUsed)) && ((err3.instancePath === instancePath+"/hostname") || ((err3.instancePath.indexOf(instancePath+"/hostname") === 0) && (err3.instancePath[instancePath+"/hostname".length] === "/")))) && (err3.schemaPath.indexOf("#/properties/hostname") === 0)) && (err3.schemaPath["#/properties/hostname".length] === "/")){emErrs0.push(err3);err3.emUsed = true;}}if(emErrs0.length){const err4 = {instancePath:instancePath+"/hostname",schemaPath:"#/properties/hostname/errorMessage",keyword:"errorMessage",params:{errors: emErrs0},message:"`hostname` must be a string"};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}const emErrs1 = [];for(const err5 of vErrors){if(!err5.emUsed){emErrs1.push(err5);}}vErrors = emErrs1;errors = emErrs1.length;}}}else {const err6 = {instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}if(errors > 0){const emErrs2 = [];for(const err7 of vErrors){if(((((err7.keyword !== "errorMessage") && (!err7.emUsed)) && ((err7.instancePath === instancePath) || ((err7.instancePath.indexOf(instancePath) === 0) && (err7.instancePath[instancePath.length] === "/")))) && (err7.schemaPath.indexOf("#") === 0)) && (err7.schemaPath["#".length] === "/")){emErrs2.push(err7);err7.emUsed = true;}}if(emErrs2.length){const err8 = {instancePath,schemaPath:"#/errorMessage",keyword:"errorMessage",params:{errors: emErrs2},message:"`client.connect_wallet` must only be given `hostname`"};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}const emErrs3 = [];for(const err9 of vErrors){if(!err9.emUsed){emErrs3.push(err9);}}vErrors = emErrs3;errors = emErrs3.length;}validate14.errors = vErrors;return errors === 0;}
